input ActionObjectUnionAsInput {
  id: ID!
  producer: ID
  facility: ID
  vehicle: ID
  pathType: PathTypeEnumAsInput
  tiles: [ID]
  order: OrderAsInput
}

type ActionObjectUnionOutput {
  id: ID!
  producer: ID
  facility: ID
  vehicle: ID
  pathType: PathTypeEnum
  tiles: [ID]
  order: Order
}

type ActionProgress {
  id: ID!
  type: ActionTypeEnumOutput!
  step: Float!
  remainingSteps: Float!
  status: ActionStatusEnum!
  info: String
  object: ActionObjectUnionOutput!
  sim: ID!
}

input ActionProgressAsInput {
  id: ID!
  type: ActionTypeEnumAsInput!
  step: Float!
  remainingSteps: Float!
  status: ActionStatusEnumAsInput!
  info: String
  object: ActionObjectUnionAsInput!
  sim: ID!
}

input ActionsReportAsInput {
  id: ID!
  progress: [ActionProgressAsInput!]!
  ok: Boolean!
}

type ActionsReportOutput {
  id: ID!
  progress: [ActionProgress!]!
  ok: Boolean!
}

type ActionStatusEnum {
  id: ID!
}

input ActionStatusEnumAsInput {
  id: ID!
}

input ActionTypeEnumAsInput {
  id: ID!
}

type ActionTypeEnumOutput {
  id: ID!
}

type ActionTypeRequirement {
  id: ID!
  type: ActionTypeEnumOutput!
  time: Float!
  cost: Float!
  inputs: [ProductQuantityOutput!]!
}

input ActionTypeRequirementAsInput {
  id: ID!
  type: ActionTypeEnumAsInput!
  time: Float!
  cost: Float!
  inputs: [ProductQuantityAsInput!]!
}

enum AggregateOp {
  MIN
  MAX
  SUM
  COUNT
}

type City {
  id: ID!
  sim: ID!
  population: Float!
  consumables: [Consumable!]!
  level: CityLevel!
  x: Int!
  y: Int!
}

input CityAsInput {
  id: ID!
  sim: ID!
  population: Float!
  consumables: [ConsumableAsInput!]!
  level: CityLevelAsInput!
  x: Int!
  y: Int!
}

type CityConfig {
  id: ID!
  growthRate: Float!
  declineRate: Float!
  initialPopulation: Float!
  demandsPerPersonPerStep: [ProductQuantityOutput!]!
  defaultLevel: ID!
  consumables: [Consumable!]!
  density: Float!
}

input CityConfigAsInput {
  id: ID!
  growthRate: Float!
  declineRate: Float!
  initialPopulation: Float!
  demandsPerPersonPerStep: [ProductQuantityAsInput!]!
  defaultLevel: ID!
  consumables: [ConsumableAsInput!]!
  density: Float!
}

type CityLevel {
  id: ID!
  storageCapacityModifier: Float!
  actionTypeRequirements: [ActionTypeRequirement!]!
  nextLevel: ID
}

input CityLevelAsInput {
  id: ID!
  storageCapacityModifier: Float!
  actionTypeRequirements: [ActionTypeRequirementAsInput!]!
  nextLevel: ID
}

type Company {
  id: ID!
  name: String!
  credit: Float!
  facilityUnlocks: [FacilityLevel!]!
  vehicleUnlocks: [VehicleLevel!]!
  producerUnlocks: [ProducerLevel!]!
  storageDepotUnlocks: [SupplyDepotLevel!]!
  config: CompanyConfigOutput!
}

input CompanyConfigAsInput {
  id: ID!
  initialCredit: Float!
}

type CompanyConfigOutput {
  id: ID!
  initialCredit: Float!
}

input CompanyReportAsInput {
  id: ID!
  production: ProductionReportAsInput!
  actions: ActionsReportAsInput!
}

type CompanyReportOutput {
  id: ID!
  production: ProductionReportOutput!
  actions: ActionsReportOutput!
}

type Consumable {
  id: ID!
  storage: StorageOutput!
  basePricePerUnit: Float!
  minPriceBasisPct: Float!
}

input ConsumableAsInput {
  id: ID!
  storage: StorageAsInput!
  basePricePerUnit: Float!
  minPriceBasisPct: Float!
}

type CounterpartyUnion {
  id: ID!
  city: City
  producer: ProducerOutput
}

input CounterpartyUnionAsInput {
  id: ID!
  city: CityAsInput
  producer: ProducerAsInput
}

scalar Date

scalar DateTime

type Facility {
  id: ID!
  sim: ID!
  type: FacilityTypeEnum!
  level: FacilityLevel!
  x: Int!
  y: Int!
}

input FacilityAsInput {
  id: ID!
  sim: ID!
  type: FacilityTypeEnumAsInput!
  level: FacilityLevelAsInput!
  x: Int!
  y: Int!
}

"""
Autogenerated input for modifying instance of Facility
"""
type FacilityInputProxy {
  id: ID!
  sim: ID
  type: ID
  level: ID
  x: Int
  y: Int
}

type FacilityLevel {
  id: ID!
  type: FacilityTypeEnum!
  nextLevel: ID
  maxVehicleLevel: ID
  energyDemandBaseline: Float!
  fuelDemandBaseline: Float!
  fuelStorage: StorageOutput!
  perVehicleEnergyFactor: Float!
  perVehicleFuelFactor: Float!
  repairEfficiency: Float!
  actionRequirements: [ActionTypeRequirement!]!
}

input FacilityLevelAsInput {
  id: ID!
  type: FacilityTypeEnumAsInput!
  nextLevel: ID
  maxVehicleLevel: ID
  energyDemandBaseline: Float!
  fuelDemandBaseline: Float!
  fuelStorage: StorageAsInput!
  perVehicleEnergyFactor: Float!
  perVehicleFuelFactor: Float!
  repairEfficiency: Float!
  actionRequirements: [ActionTypeRequirementAsInput!]!
}

type FacilityTypeEnum {
  id: ID!
}

input FacilityTypeEnumAsInput {
  id: ID!
}

input FieldFilterInput {
  """
  one of the following is required
  """
  fieldId: ID
  fieldName: String
  op: String!
  value: FieldValueInput!
}

input FieldProjectionInput {
  """
  one of the following is required - except in the case of count queries
  """
  fieldId: ID
  fieldName: String

  """
  optional if omitted outer query is used
  """
  alias: String
  op: AggregateOp
}

type FieldValue {
  """
  Types
  """
  ID: ID
  STRING: String
  INT: Int
  FLOAT: Float
  BOOLEAN: Boolean
  DATE: Date
  TIME: Time
  DATETIME: DateTime
  JSON: JSON
  KIND: ID

  """
  List forms
  """
  l_ID: [ID]
  l_STRING: [String]
  l_INT: [Int]
  l_FLOAT: [Float]
  l_BOOLEAN: [Boolean]
  l_DATE: [Date]
  l_TIME: [Time]
  l_DATETIME: [DateTime]
  l_JSON: [JSON]
  l_KIND: [ID]
}

input FieldValueInput {
  """
  Types
  """
  ID: ID
  STRING: String
  INT: Int
  FLOAT: Float
  BOOLEAN: Boolean
  DATE: Date
  TIME: Time
  DATETIME: DateTime
  JSON: JSON
  KIND: ID

  """
  List forms
  """
  l_ID: [ID]
  l_STRING: [String]
  l_INT: [Int]
  l_FLOAT: [Float]
  l_BOOLEAN: [Boolean]
  l_DATE: [Date]
  l_TIME: [Time]
  l_DATETIME: [DateTime]
  l_JSON: [JSON]
  l_KIND: [ID]
}

type Info {
  id: ID!
  name: String!
  description: String
}

type InstanceSet {
  kindId: ID!

  """
  Continuation token
  """
  token: String
  fieldIds: [ID]

  """
  rowKeys: [Int]
  """
  records: [[FieldValue]]
}

scalar JSON

input KindQueryInput {
  """
  projected kind (one of the following is required)
  """
  kindId: ID
  kindName: String
  serviceId: ID

  """
  optional alias for projection binding
  """
  alias: String

  """
  projected fields
  """
  projection: [FieldProjectionInput]

  """
  distinct Projected result
  """
  distinct: Boolean

  """
  filters (where)
  """
  fieldFilters: [FieldFilterInput]

  """
  conjunction (where)
  """
  and: [KindQueryInput]

  """
  disjunction (where)
  """
  or: [KindQueryInput]

  """
  join (if conjunction or disjunction)
  """
  fromFieldId: ID
  fromFieldName: String
  toFieldId: ID
  toFieldName: String
  take: Int
  token: String
}

type Map {
  id: ID!
  sizeX: Int!
  sizeY: Int!
}

input MapAsInput {
  id: ID!
  sizeX: Int!
  sizeY: Int!
}

input MapConfigAsInput {
  id: ID!
  loadConfig: MapLoadConfigAsInput
  generateConfig: MapGenerationConfigAsInput
}

type MapConfigOutput {
  id: ID!
  loadConfig: MapLoadConfig
  generateConfig: MapGenerationConfig
}

type MapGenerationConfig {
  id: ID!
  sizeX: Int!
  sizeY: Int!
}

input MapGenerationConfigAsInput {
  id: ID!
  sizeX: Int!
  sizeY: Int!
}

type MapLoadConfig {
  id: ID!
}

input MapLoadConfigAsInput {
  id: ID!
}

type Mutation {
  evaluateSimulationStep(
    sim: ID!
    companyReport: CompanyReportAsInput!
  ): SimulationStepResult!
  generateOrLoadMap(config: MapConfigAsInput!, sim: ID!): Map!
  evaluateCompany(
    sim: ID!
    productionReport: ProductionReportAsInput!
    actionsReport: ActionsReportAsInput!
  ): CompanyReportOutput!
  newSimulation(
    companyName: String!
    config: SimulationConfigAsInput!
  ): Simulation!
  stepSimulation(
    sim: ID!
    actionType: ActionTypeEnumAsInput
    actionObject: ActionObjectUnionAsInput
  ): SimulationStepResult!
  stepActions(
    sim: ID!
    actionType: ActionTypeEnumAsInput
    actionObject: ActionObjectUnionAsInput
  ): ActionsReportOutput!
  stepActiveActions(sim: ID!): [ActionProgress!]!
  stepProduction(sim: ID!): ProductionReportOutput!
  stepProducer(producer: ProducerAsInput!): StorageTransactionReport!
  deposit(storageAmount: StorageAmountAsInput!): StorageTransaction!
  commitTransactions(
    transactions: [StorageTransactionAsInput!]!
    ok: Boolean!
  ): [ID!]!
  idOrUUID(id: ID): ID!
  makeSimulationId(companyName: String!, map: ID!): ID!
  startNewAction(
    sim: ID!
    actionType: ActionTypeEnumAsInput
    actionObject: ActionObjectUnionAsInput
  ): ActionProgress
  stepActionProgress(actionProgress: ActionProgressAsInput!): ActionProgress!
  newVehicle(
    sim: ID!
    x: Int!
    y: Int!
    type: ID!
    facility: ID!
    level: ID
    id: ID
  ): Vehicle!
  withdraw(storageAmount: StorageAmountAsInput!): StorageTransaction!
  newProducer(map: ID!, type: ID!, level: ID!, x: Int!, y: Int!): ID
  cloneMapForSim(sim: ID!, map: ID!): ID!
  evaluateProduction(
    sim: ID!
    transactions: [StorageTransactionReportAsInput!]!
  ): ProductionReportOutput!
  newMapInstance(map: ID!, sim: ID!): SimObjects!
  newCity(sim: ID!, x: Int!, y: Int!, level: ID, id: ID): City!
  _TODO_startNewAction(
    sim: ID!
    actionType: ActionTypeEnumAsInput
    actionObject: ActionObjectUnionAsInput
  ): ActionProgress
  newFacility(
    sim: ID!
    x: Int!
    y: Int!
    type: ID!
    level: ID
    id: ID
  ): Facility!
  newSupplyDepot(sim: ID!, x: Int!, y: Int!, level: ID, id: ID): SupplyDepot!
  rewriteProducersForSim(
    producers: [ProducerAsInput!]!
    sim: ID!
  ): [ProducerInputProxy!]!
  placeOrThrow(sim: ID!, x: Int!, y: Int!, type: TileTypeEnumAsInput!): ID!
  newPath(
    sim: ID!
    type: ID!
    orderedLocations: [OrderedLocationAsInput!]!
    id: ID
  ): Path!

  """
  Clear cache for this service
  """
  clearCache: Boolean!
}

type Order {
  id: ID!
  product: ProductQuantityOutput!
  orderType: OrderTypeEnum!
  vehicle: ID!
  paths: [ID!]!
  counterparty: CounterpartyUnion!
  sim: ID!
}

input OrderAsInput {
  id: ID!
  product: ProductQuantityAsInput!
  orderType: OrderTypeEnumAsInput!
  vehicle: ID!
  paths: [ID!]!
  counterparty: CounterpartyUnionAsInput!
  sim: ID!
}

input OrderedLocationAsInput {
  id: ID!
  order: Int!
  x: Int!
  y: Int!
  sim: ID!
  path: ID!
}

type OrderedLocationOutput {
  id: ID!
  order: Int!
  x: Int!
  y: Int!
  sim: ID!
  path: ID!
}

type OrderTypeEnum {
  id: ID!
}

input OrderTypeEnumAsInput {
  id: ID!
}

type Path {
  id: ID!
  type: PathTypeEnum!
  orderedLocations: [OrderedLocationOutput!]!
  sim: ID!
}

input PathAsInput {
  id: ID!
  type: PathTypeEnumAsInput!
  orderedLocations: [OrderedLocationAsInput!]!
  sim: ID!
}

type PathConfig {
  id: ID!
  type: PathTypeEnum!
  actionRequirements: [ActionTypeRequirement!]!
}

input PathConfigAsInput {
  id: ID!
  type: PathTypeEnumAsInput!
  actionRequirements: [ActionTypeRequirementAsInput!]!
}

"""
Autogenerated input for modifying instance of Path
"""
type PathInputProxy {
  id: ID!
  type: ID
  orderedLocations: [ID]
  sim: ID
}

type PathTypeEnum {
  id: ID!
}

input PathTypeEnumAsInput {
  id: ID!
}

input ProducerAsInput {
  id: ID!
  sim: ID!
  level: ProducerLevelAsInput!
  storage: [StorageAsInput!]!
  type: ProducerTypeEnumAsInput!
  x: Int!
  y: Int!
}

"""
Autogenerated input for modifying instance of Producer
"""
type ProducerInputProxy {
  id: ID!
  sim: ID
  level: ID
  storage: [ID]
  type: ID
  x: Int
  y: Int
}

type ProducerLevel {
  id: ID!
  actionRequirements: [ActionTypeRequirement!]!
  baseCostPerUnit: Float!
  stoppageSurchargeRate: Float!
  nextLevel: ID
  inputs: [ProductQuantityOutput!]!
  outputs: [ProductQuantityOutput!]!
  storage: [ProductQuantityOutput!]!
}

input ProducerLevelAsInput {
  id: ID!
  actionRequirements: [ActionTypeRequirementAsInput!]!
  baseCostPerUnit: Float!
  stoppageSurchargeRate: Float!
  nextLevel: ID
  inputs: [ProductQuantityAsInput!]!
  outputs: [ProductQuantityAsInput!]!
  storage: [ProductQuantityAsInput!]!
}

type ProducerOutput {
  id: ID!
  sim: ID!
  level: ProducerLevel!
  storage: [StorageOutput!]!
  type: ProducerTypeEnum!
  x: Int!
  y: Int!
}

type ProducerTypeEnum {
  id: ID!
}

input ProducerTypeEnumAsInput {
  id: ID!
}

input ProductionReportAsInput {
  id: ID!
  producerReports: [StorageTransactionReportAsInput!]!
  ok: Boolean!
}

type ProductionReportOutput {
  id: ID!
  producerReports: [StorageTransactionReport!]!
  ok: Boolean!
}

input ProductQuantityAsInput {
  id: ID!
  type: ProductTypeEnumAsInput!
  quantity: Float!
}

type ProductQuantityOutput {
  id: ID!
  type: ProductTypeEnum!
  quantity: Float!
}

type ProductTypeEnum {
  id: ID!
}

input ProductTypeEnumAsInput {
  id: ID!
}

type Query {
  """
  Mandatory service manifest.
  """
  info: Info!

  """
  Kind Query
  """
  query(input: KindQueryInput!): InstanceSet
  queryJSON(input: KindQueryInput!): String
  defaultSimulationConfigId: ID!
  defaultSimulationConfig: SimulationConfigOutput!
  newCompany(companyName: String!, config: CompanyConfigAsInput!): ID!
  prepareStorageAmounts(
    quantities: [ProductQuantityAsInput!]!
    storages: [StorageAsInput!]!
  ): [StorageAmountOutput!]!
  depositAmounts(amounts: [StorageAmountAsInput!]!): [StorageTransaction!]!
  withdrawAmounts(amounts: [StorageAmountAsInput!]!): [StorageTransaction!]!
  newStorage(requirement: ProductQuantityAsInput!): ID!
  cloneVehiclesForSim(map: ID!, sim: ID!): [Vehicle!]!
  validateTransactions(transactions: [StorageTransactionAsInput!]!): Boolean!
  loadMap(config: MapConfigAsInput!): Map
  invalidTilePlacementMsg: String!
  evaluateActionProgress(
    sim: ID!
    progress: [ActionProgressAsInput!]!
  ): ActionsReportOutput!
  generateMap(config: MapConfigAsInput!): Map
  pickValidMap(a: MapAsInput, b: MapAsInput): Map!
  prepareStorageTransactionsForCommit(
    transactions: [StorageTransactionAsInput!]!
    ok: Boolean!
  ): [StorageInputProxy!]!
  makeStorageTransactionReport(
    withdrawals: [StorageTransactionAsInput!]!
    withdrawalCommits: [ID!]!
    ok: Boolean!
    deposits: [StorageTransactionAsInput!]!
    depositCommits: [ID!]!
  ): StorageTransactionReport!
  cloneCitiesForSim(map: ID!, sim: ID!): [City!]!
  cloneFacilitiesForSim(map: ID!, sim: ID!): [Facility!]!
  cloneSupplyDepotsForSim(map: ID!, sim: ID!): [SupplyDepot!]!
  rewriteFacilitiesForSim(
    facilities: [FacilityAsInput!]!
    sim: ID!
  ): [FacilityInputProxy!]!
  rewriteSupplyDepotsForSim(
    depots: [SupplyDepotAsInput!]!
    sim: ID!
  ): [SupplyDepotInputProxy!]!
  cloneProducersForSim(map: ID!, sim: ID!): [ProducerOutput!]!
  clonePathsForSim(map: ID!, sim: ID!): [Path!]!
  rewritePathsForSim(path: [PathAsInput!]!, sim: ID!): [PathInputProxy!]!
  rewriteVehiclesForSim(
    vehicles: [VehicleAsInput!]!
    sim: ID!
  ): [VehicleInputProxy!]!
  _TODO_cloneMapForSim(sim: ID!, map: ID!): ID!

  """
  Right-biased
  """
  eitherId(left: ID, right: ID): ID!
  rewriteCitiesForSim(cities: [CityAsInput!]!, sim: ID!): [City!]!
  CKGErrors: [String]
}

type SimObjects {
  id: ID!
  cities: [City!]!
  producers: [ProducerOutput!]!
  facilities: [Facility!]!
  paths: [Path!]!
  vehicles: [Vehicle!]!
  supplyDepots: [SupplyDepot!]!
}

type Simulation {
  id: ID!
  config: SimulationConfigOutput!
  company: Company!
  map: Map!
  step: Float!
  status: SimulationStatusEnum!
}

input SimulationConfigAsInput {
  id: ID!
  seed: Float!
  mapConfig: MapConfigAsInput!
  companyConfig: CompanyConfigAsInput!
  cityConfig: CityConfigAsInput!
  pathConfigs: [PathConfigAsInput!]!
}

type SimulationConfigOutput {
  id: ID!
  seed: Float!
  mapConfig: MapConfigOutput!
  companyConfig: CompanyConfigOutput!
  cityConfig: CityConfig!
  pathConfigs: [PathConfig!]!
}

type SimulationStatusEnum {
  id: ID!
}

type SimulationStepResult {
  id: ID!
  status: SimulationStatusEnum!
  companyReport: CompanyReportOutput!
}

input StorageAmountAsInput {
  id: ID!
  storage: StorageAsInput!
  amount: Float!
}

type StorageAmountOutput {
  id: ID!
  storage: StorageOutput!
  amount: Float!
}

input StorageAsInput {
  id: ID!
  product: ProductTypeEnumAsInput!
  capacity: Float!
  amount: Float!
}

type StorageInputProxy {
  id: ID!
  product: ID
  capacity: Float
  amount: Float
}

type StorageOutput {
  id: ID!
  product: ProductTypeEnum!
  capacity: Float!
  amount: Float!
}

type StorageTransaction {
  id: ID!
  storage: StorageOutput!
  originalAmount: Float!
  requestedAmount: Float!
  actualAmount: Float!
  ok: Boolean!
}

input StorageTransactionAsInput {
  id: ID!
  storage: StorageAsInput!
  originalAmount: Float!
  requestedAmount: Float!
  actualAmount: Float!
  ok: Boolean!
}

type StorageTransactionReport {
  id: ID!
  withdrawals: [StorageTransaction!]!
  deposits: [StorageTransaction!]!
  withdrawalCommits: [ID!]!
  depositCommits: [ID!]!
  ok: Boolean!
}

input StorageTransactionReportAsInput {
  id: ID!
  withdrawals: [StorageTransactionAsInput!]!
  deposits: [StorageTransactionAsInput!]!
  withdrawalCommits: [ID!]!
  depositCommits: [ID!]!
  ok: Boolean!
}

type SupplyDepot {
  id: ID!
  sim: ID!
  level: SupplyDepotLevel!
  x: Int!
  y: Int!
}

input SupplyDepotAsInput {
  id: ID!
  sim: ID!
  level: SupplyDepotLevelAsInput!
  x: Int!
  y: Int!
}

"""
Autogenerated input for modifying instance of SupplyDepot
"""
type SupplyDepotInputProxy {
  id: ID!
  sim: ID
  level: ID
  x: Int
  y: Int
}

type SupplyDepotLevel {
  id: ID!
  storage: [StorageOutput!]!
  nextLevel: ID
  actionRequirements: [ActionTypeRequirement!]!
}

input SupplyDepotLevelAsInput {
  id: ID!
  storage: [StorageAsInput!]!
  nextLevel: ID
  actionRequirements: [ActionTypeRequirementAsInput!]!
}

input TileTypeEnumAsInput {
  id: ID!
}

scalar Time

type Vehicle {
  id: ID!
  level: VehicleLevel!
  sim: ID!
  type: VehicleTypeEnum!
  facility: ID!
  x: Int!
  y: Int!
}

input VehicleAsInput {
  id: ID!
  level: VehicleLevelAsInput!
  sim: ID!
  type: VehicleTypeEnumAsInput!
  facility: ID!
  x: Int!
  y: Int!
}

"""
Autogenerated input for modifying instance of Vehicle
"""
type VehicleInputProxy {
  id: ID!
  level: ID
  sim: ID
  type: ID
  facility: ID
  x: Int
  y: Int
}

type VehicleLevel {
  id: ID!
  cargoCapacity: [ProductQuantityOutput!]!
  maxSpeed: Float!
  maxDistance: Float!
  reliability: Float!
  maintainAfterSteps: Int!
  durability: Float!
}

input VehicleLevelAsInput {
  id: ID!
  cargoCapacity: [ProductQuantityAsInput!]!
  maxSpeed: Float!
  maxDistance: Float!
  reliability: Float!
  maintainAfterSteps: Int!
  durability: Float!
}

type VehicleTypeEnum {
  id: ID!
}

input VehicleTypeEnumAsInput {
  id: ID!
}
